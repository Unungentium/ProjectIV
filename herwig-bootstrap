#!/usr/bin/env python
import subprocess,glob
import sys, os, errno, platform, shutil, ssl

try:
    from urllib.request import Request as Request
    from urllib.request import urlopen as urlopen
    from urllib.error   import URLError as URLError
    from urllib.error   import HTTPError as HTTPError
except ImportError:
    from urllib2 import Request as Request
    from urllib2 import urlopen as urlopen
    from urllib2 import URLError as URLError
    from urllib2 import HTTPError as HTTPError

import tarfile
from optparse import OptionParser, OptionGroup
from optparse import SUPPRESS_HELP as NOHELP
from time import sleep

if platform.system() == 'Darwin':
    default_cc  = os.getenv('CC',  '/usr/bin/clang')
    default_cxx = os.getenv('CXX', '/usr/bin/clang++')
    default_fc  = os.getenv('FC',  None)
else:
    default_cc  = os.getenv('CC',  'gcc')
    default_cxx = os.getenv('CXX', 'g++')
    default_fc  = os.getenv('FC',  'gfortran')

# from http://stackoverflow.com/a/377028
def which(program):
    import os
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None



parser = OptionParser(usage='Usage: %prog [options] DEST_DIR\n'
                            '       %prog --help')

without_helptext = """
can optionally be satisfied with pre-existing installations. Specifying the PATH to an
existing installation will prevent a local build.
Each --with-FOO option has a corresponding --without-FOO,
to disable that package completely.
We can't help with build errors arising from use of --with and --without!
"""

parser_core = OptionGroup(parser,"Override main dependencies",
                          "The main dependencies for Herwig"+without_helptext)

parser_nlo = OptionGroup(parser,"Override NLO dependencies",
                          "The dependencies on NLO providers"+without_helptext)

parser_scm = OptionGroup(parser,"Source code repositories (for developers)",
                          "Some dependencies are also available as "
                          "direct source code checkouts. "
                          "Default repo URLs are already provided, you only "
                          "need to use the --foo-repo= options to change the defaults.")

parser_versions = OptionGroup(parser, "Code versions",
                                "Change the default version of the installation.")

parser_misc = OptionGroup(parser,"Miscellaneous options",
                          "Options for special use cases, not required for a regular build.")

parser.add_option_group(parser_core)
parser.add_option_group(parser_nlo)
parser.add_option_group(parser_versions)
parser.add_option_group(parser_scm)
parser.add_option_group(parser_misc)

# src directory
parser_misc.add_option("--src-dir",
                  metavar='PATH',
                  type='string',
                  default="",
                  dest='src_dir',
                  help='Separate the source/build directory. [DEST_DIR/src]')

# lite optin (build a minimal set of packages)
def lite(option, opt, value, parser):
    non_lite_components = ['vbfnlo', 'madgraph', 'evtgen', 'yoda', 'njet', 'gosam', 'openloops', 'hjets', 'rivet', 'fastjet_contrib', 'pythia']
    for program in non_lite_components:
        setattr(parser.values, program, False)
    pass

parser_misc.add_option("--lite",action="callback", callback=lite,help='Build the minimal set of packages to run Herwig')

# function to set up the standard flags for a program
def setUpFlags(parser,program,version) :
    parser.add_option("--with-"+program   ,
                      dest=program+'_loc',
                      metavar='PATH',
                      default=None,
                      help="")
    parser.add_option("--without-"+program,
                      action='store_false',
                      dest=program,
                      default=True,
                      help=NOHELP)
    if version:
        parser_versions.add_option("--"+program+"-version",
                          metavar='VER',
                          type='string',
                          default=version,
                          dest=program+"_ver",
                          help="[%default]")
# compiler building
parser.add_option("--build-gcc",
                  action='store_true' ,
                  dest="gcc",
                  default=False,
                  help="Build a local copy of the gcc compilers to use for the rest of bootstrap.")

parser_versions.add_option("--gcc-version",
                  metavar='VER',
                  type='string',
                  default='8.2.0',
                  dest="gcc_ver",
                  help="[%default]")

# C++ 11
parser.add_option("--c++11-flag",
                  metavar="'...'",
                  type='string',
                  dest="cxx11",
                  default='-std=c++11',
                  help="Compiler flag which enables C++11 compatibility. ['%default']")

# gengetopt
parser_misc.add_option("--build-gengetopt",
                      action='store_true' ,
                      dest='gengetopt',
                      default=False,
                      help="Always build a local version of gengetopt instead of automatic detection.")

# flags for boost (N.B. 1.69 puts x64 in lib names so won't work till we get a boost.m4 which supports it)
setUpFlags(parser_core,"boost","1.71.0")
parser_misc.add_option("--boost-all",
                  action='store_false',
                  dest="boost_minimal",
                  default=True,
                  help='Install all the boost libaries, including those not required by Herwig.')
# flags for gsl
setUpFlags(parser_core,"gsl","2.6")
# flags for fastjet
setUpFlags(parser_core,"fastjet","3.3.2")
# flags for fastjet
setUpFlags(parser_core,"fastjet_contrib","1.042")
# flags for hepmc
setUpFlags(parser_core,"hepmc","2.06.09")
# flags for lhapdf
setUpFlags(parser_core,"lhapdf","6.3.0")
parser_misc.add_option("--add-pdf",
                  metavar='PDF',
                  action='append',
                  dest="pdfs",
                  default=["MMHT2014lo68cl","MMHT2014nlo68cl","CT14lo","CT14nlo"],
                  help='Add a PDF to the defaults %default')
# flags for yoda
setUpFlags(parser_core,"yoda","1.8.1")
parser_scm.add_option("--yoda-hg",
                  action='store_true',
                  dest="yoda_hg",
                  default=False,
                  help='')
parser_scm.add_option("--yoda-repo",
                  metavar='URL',
                  type='string',
                  default="https://phab.hepforge.org/source/yodahg/",
                  dest='yoda_repo',
                  help='[%default]')
parser_misc.add_option("--yoda-disable-root",
                  action='store_false',
                  dest='yoda_root',
                  default=True,
                  help='Configure YODA with the --disable-root option.')
# flags for rivet
setUpFlags(parser_core,"rivet","3.1.0")
parser_scm.add_option("--rivet-hg",
                  action='store_true',
                  dest="rivet_hg",
                  default=False,
                  help='')
parser_scm.add_option("--rivet-repo",
                  metavar='URL',
                  type='string',
                  default="https://phab.hepforge.org/source/rivethg/",
                  dest='rivet_repo',
                  help='[%default]')
# flags for thepeg
setUpFlags(parser_core,"thepeg","2.2.1")
parser_scm.add_option("--thepeg-hg",
                  action='store_true',
                  dest="thepeg_hg",
                  default=False,
                  help='')
parser_scm.add_option("--thepeg-repo",
                  metavar='URL',
                  type='string',
                  default="https://phab.hepforge.org/source/thepeghg/",
                  dest='thepeg_repo',
                  help='[%default]')

# flags for herwig
setUpFlags(parser_core,"herwig","7.2.1")
parser_scm.add_option("--herwig-hg",
                  action='store_true',
                  dest="herwig_hg",
                  default=False,
                  help='')
parser_scm.add_option("--herwig-repo",
                  metavar='URL',
                  type='string',
                  default="https://phab.hepforge.org/source/herwighg/",
                  dest='herwig_repo',
                  help=' [%default]')
# madgraph
setUpFlags(parser_nlo,"madgraph","2.7.3")
parser_scm.add_option("--madgraph-bzr",
                  action='store_true',
                  dest="madgraph_bzr",
                  default=False,
                  help='')
parser_scm.add_option("--madgraph-repo",
                  metavar='URL',
                  type='string',
                  default="lp:~matchboxteam/mg5amcnlo/matchbox_output",
                  dest='madgraph_repo',
                  help='[%default]')
# flags for njet
setUpFlags(parser_nlo,"njet","2.0.0")
# flags for vbfnlo
setUpFlags(parser_nlo,"vbfnlo","3.0.0beta5")
parser_misc.add_option("--vbfnlo-processes",
                  metavar='PROCS',
                  type='string',
                  default="vbf,hjjj",
                  dest='vbfnlo_processes',
                  help='The processes for VBFNLO [%default]')
parser_scm.add_option("--vbfnlo-git",
                  action='store_true',
                  dest="vbfnlo_git",
                  default=False,
                  help='')
parser_scm.add_option("--vbfnlo-repo",
                  metavar='URL',
                  type='string',
                  default="https://github.com/vbfnlo/vbfnlo.git",
                  dest='vbfnlo_repo',
                  help='[%default]')
# flags for GoSam
setUpFlags(parser_nlo,"gosam","")
# flags for OpenLoops
setUpFlags(parser_nlo,"openloops","2.1.1")
parser_scm.add_option("--openloops-svn",
                  action='store_true',
                  dest="openloops_svn",
                  default=False,
                  help='')
parser_scm.add_option("--openloops-repo",
                  metavar='URL',
                  type='string',
                  default="svn+ssh://phab.hepforge.org/source/openloopssvn/OpenLoops/",
                  dest='openloops_repo',
                  help='[%default]')
parser_misc.add_option("--openloops-processes",
                  metavar='PROCS',
                  type='string',
                  default="ppll",
                  dest='openloops_processes',
                  help='The processes for OpenLoops [%default]')
# flags for hjets
setUpFlags(parser_nlo,"hjets","1.2")
parser_scm.add_option("--hjets-hg",
                  action='store_true',
                  dest="hjets_hg",
                  default=False,
                  help='')
parser_scm.add_option("--hjets-repo",
                  metavar='URL',
                  type='string',
                  default="https://hjets.hepforge.org/hg/hjets",
                  dest='hjets_repo',
                  help='[%default]')

## Dependencies for EvtGen
# pythia
setUpFlags(parser_core,"pythia",None)
# version needs to be held fixed at R01-07-00
setUpFlags(parser_core,"evtgen",None)

# no of cores
try:
    from multiprocessing import cpu_count
    ncore = max(cpu_count()-1, 1)
    del cpu_count
except:
    ncore = 1

parser.add_option("-j",
                  type='int',
                  metavar='N',
                  default=ncore,
                  dest="ncore",
                  help="Use N cores in make -j to speed up compilation. [%default]")

del ncore

# get the options and locations
opts, install_dir = parser.parse_args()

if len(install_dir) != 1:
    parser.print_usage(sys.stderr)
    exit(1)
install_dir = install_dir[0]

# enable C++11
default_cxx = "%s %s" % (default_cxx, opts.cxx11)

# gengetopt is always needed for Herwig hg build
if opts.herwig_hg and which('gengetopt') is None:
    opts.gengetopt = True

if platform.system() == 'Darwin':
    # problem with dd_real from libqd
    opts.njet = False
    sys.stderr.write("* OS X: disabling NJet (need more dd_real overloads for math.h) *\n")

    if opts.gcc:
        sys.stderr.write("""
*********************************************************
*
* Self-building the compilers is not supported on OS X.
*
* Set FC to a Fortran compiler you have installed from
* another source (e.g. MacPorts, Fink or Homebrew) and
* rerun bootstrap without '--build-gcc'.
*
*********************************************************

""")
        sys.exit(1)

    if default_fc is None:
        sys.stderr.write("""
*********************************************************
*
* Set FC to a Fortran compiler you have installed from
* another source (e.g. MacPorts, Fink or Homebrew).
*
*********************************************************

""")
        sys.exit(1)

if not opts.gcc:
    print ("""
*********************************************************
* Using CC="%s" CXX="%s" FC="%s".
* Set these environment variables to change compilers.
*********************************************************

""" % (default_cc,default_cxx,default_fc))

else:
    print ("""
*********************************************************************
* Using self-installed CC, CXX and FC. To use other compilers,
* remove --build-gcc and optionally set these 3 environment variables.
*********************************************************************

""")

# warnings and checks for python 3
if sys.version_info[0] == 3:
    print (
"""
Python 3 support is currently experimental, and a number of
Herwig dependencies which use python internally, do not support
python3 yet
""")
    if opts.gosam :
        print ("Gosam does not support python 3, disabling\n")
        opts.gosam = False

    if which("cython") is None:
        print (
"""Python 3 install needs cython to rebuild lhapdf, yoda and
   rivet python interfaces
""")
        quit()

    if which("autoreconf") is None:
        print ("Python 3 install needs autoreconf to rebuild lhapdf configure script\n")
        quit()
sleep(1)



# set the base directory
current_dir=os.getcwd()

base_dir=os.path.join(current_dir,install_dir)
if not os.path.isdir(base_dir):
    os.mkdir(base_dir)

opt_dir = os.path.join(base_dir,'opt')
if not os.path.isdir(opt_dir):
    os.mkdir(opt_dir)

if not opts.src_dir:
    src_dir = os.path.join(base_dir,'src')
else:
    src_dir = os.path.join(current_dir,opts.src_dir)
if not os.path.isdir(src_dir):
    os.mkdir(src_dir)

# store the used command line for easy repetition later
current_cmdline = [
    'CC="%s"'  % default_cc,
    'CXX="%s"' % default_cxx,
    'FC="%s"'  % default_fc,
]
current_cmdline += sys.argv

with open(os.path.join(src_dir,'herwig_bootstrap_last_cmd'),'w') as f:
    f.write(' '.join(current_cmdline)+'\n')

del current_cmdline

os.chdir(src_dir)


# set the environment variables
bin_dir = os.path.join(base_dir,'bin')
try:
    os.environ['PATH'] = os.pathsep.join([bin_dir, os.environ['PATH']])
except KeyError:
    os.environ['PATH'] = bin_dir


ld_env_name = 'LD_LIBRARY_PATH' if platform.system() != 'Darwin' else 'DYLD_LIBRARY_PATH'
libpaths = [os.path.join(base_dir,'lib')]
if platform.system() != 'Darwin':
    libpaths.append(os.path.join(base_dir,'lib64'))
lib_dirs = os.pathsep.join(libpaths)
try:
    os.environ[ld_env_name] = os.pathsep.join([lib_dirs, os.environ[ld_env_name]])
except KeyError:
    os.environ[ld_env_name] = lib_dirs


python_path = os.pathsep.join([os.path.join(base_dir,'lib64','python'+sys.version[:3],'site-packages'),
                               os.path.join(base_dir,'lib',  'python'+sys.version[:3],'site-packages')])
try:
    os.environ['PYTHONPATH'] = os.pathsep.join([python_path, os.environ['PYTHONPATH']])
except KeyError:
    os.environ['PYTHONPATH'] = python_path


# storage of prefix info for individual packages
class Prefixes(dict):
    # return None instead of raising KeyError for unknown package name
    def __missing__(self, key):
        return None
prefix = Prefixes()

def check_call(arglist):
    print(' '.join(arglist))
    subprocess.check_call(arglist)

# checkout
def checkout( location, base, version, repo, branch, repo_type='hg', revision=None) :
    os.chdir(location)
    if repo_type == 'hg':
        directory=base
        if version:
            directory += "-"+version
        if not os.path.isdir(directory):
            check_call(["hg","clone",repo,directory])
        else:
            check_call(["hg","pull","-R",directory,repo])
        os.chdir(os.path.join(location,directory))
        if revision:
            check_call(["hg","up","-r",revision])
        else:
            check_call(["hg","up",branch])
        if os.access('Makefile',os.R_OK):
            print('Makefile exists, skipping autoreconf')
        else:
            check_call(["autoreconf","-vi"])
    elif repo_type == 'git':
        directory=base
        if version:
            directory += "-"+version
        if not os.path.isdir(directory):
            check_call(["git","clone",repo,directory])
            os.chdir(os.path.join(location,directory))
        else:
            os.chdir(os.path.join(location,directory))
            check_call(["git","pull",repo])
        if revision:
            check_call(["git","checkout",revision])
        else:
            check_call(["git","checkout",branch])
        if os.access('Makefile',os.R_OK):
            print('Makefile exists, skipping autoreconf')
        else:
            check_call(["autoreconf","-vi"])
    elif repo_type == "bzr":
        check_call(["bzr","co",repo,base])
    elif repo_type == "svn":
        if revision:
            check_call(["svn","checkout",repo+"/"+branch,base,"-r",revision])
        else:
            check_call(["svn","checkout",repo+"/"+branch,base])
        os.chdir(os.path.join(location,base))
    else:
        sys.stderr.write('Only supports checkout from hg, git, svn or bzr\n')
        exit(1)

def download_only(url_base,tar_name,distinct=False) :
    if os.access(tar_name, os.R_OK):
        print('Found existing %s' % tar_name)
        return

    if distinct:
        program_url = url_base
    else:
        program_url = '%s/%s' % (url_base,tar_name)
    print("Download %s as %s" % (program_url,tar_name))

    req_headers = {
        'User-Agent' : 'herwig-bootstrap',
        'Accept'     : '*/*'
    }
    request = Request(program_url, headers=req_headers)

    def response(request, verify_cert=True):
        """Returns response from urllib, accounting for Python2/3 function
        signatures and recursive attempt without certificate validation"""
        try:
            try:
                context = ssl.create_default_context()
                if not verify_cert:
                    context.check_hostname = False
                    context.verify_mode = ssl.CERT_NONE
                response = urlopen(request, context=context)
            except AttributeError:
                response = urlopen(request)
        except (HTTPError) as e:
            reason = getattr(e, 'reason', '[HTTPError did not provide a reason]')
            sys.stderr.write('Remote server returned error code %s: %s\n' % (e.code, reason))
            exit(1)
        except (URLError) as e:
            sys.stderr.write('Could not reach server: %s\n' % e.reason)
            if verify_cert:
                sys.stderr.write('Trying without certificates\n')
                response = response(request, False)
            else:
                exit(1)
        else:
            return response

    response = response(request)
    with open(tar_name, 'wb') as f:
        f.write(response.read())

def download(url_base,tar_name,args=[],distinct=False) :
    download_only(url_base,tar_name,distinct)
    # tarfile module can't use the 'with' context in Python 2.6
    tar = tarfile.open(tar_name,'r')
    lastfile = tar.getnames()[-1]
    if os.access(lastfile, os.R_OK):
        print('Extracted %s exists already' % lastfile.split('/')[0])
    else:
        print("Extract %s" % tar_name)
        tar.extractall()
    tar.close()


def compile(config_flags=[]) :
    if os.access('Makefile',os.R_OK):
        print('Makefile exists, skipping configure')
    else:
        if not os.access('configure', os.X_OK):
            os.chmod('configure', 0o755)
        flags = ["./configure","--prefix="+base_dir]
        flags += config_flags
        check_call(flags)
    check_call(["make","-s","-j%s" % opts.ncore])

    # TODO ?? skip here if some file already exists in /lib or /bin ??
    check_call(["make","-s","install"])
    os.chdir(src_dir)

def downloadAndCompile(url_base,base_name,suffix,config_flags) :
    download(url_base,base_name+suffix)
    os.chdir(os.path.join(src_dir,base_name))
    compile(config_flags)

def deletelibtool() :
    os.chdir(base_dir)
    for directory in ["lib","lib64","lib32"] :
        full_path = os.path.join(base_dir,directory)
        if os.path.isdir(full_path) :
            check_call(["find",full_path,"-name","*.la","-delete"])

GCC_SUFFIX = '-herwig-%s' % opts.gcc_ver

def unsupported_gcc():
    sys.stderr.write("Unsupported gcc version %s requested.\n" % opts.gcc_ver)
    sys.exit(1)

def patch(project,patchtext):
    os.chdir(os.path.join(src_dir,project))
    print('patching in %s' % os.getcwd())
    p = subprocess.Popen(['patch','-p1'], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout_data, stderr_data = p.communicate(input=patchtext)
    print(stdout_data)
    print(stderr_data)
    if p.returncode != 0:
        sys.stderr.write('patch failed\n')

def buildgcc() :
    # build gmp with --enable-fat to allow portability
    # --enable-fat currently broken on Mac, see
    # https://gmplib.org/repo/gmp/raw-rev/1fab0adc5ff7
    gmp_fatoption = ['--enable-fat']
    if platform.system() == 'Darwin':
        gmp_fatoption = []
    # build gmp
    if marker_is_missing('gmp'):
        downloadAndCompile('https://gmplib.org/download/gmp',"gmp-6.1.1",".tar.bz2",gmp_fatoption)
        prefix['gmp']=base_dir
        mark_as_done('gmp')
    # build mpfr
    if marker_is_missing('mpfr'):
        downloadAndCompile('http://mpfr.loria.fr/mpfr-3.1.5',"mpfr-3.1.5",".tar.bz2",["--with-gmp="+base_dir])
        prefix['mpfr']=base_dir
        mark_as_done('mpfr')
    # build mpc
    if marker_is_missing('mpc'):
        downloadAndCompile("https://ftpmirror.gnu.org/gnu/mpc","mpc-1.0.3",".tar.gz",["--with-gmp="+base_dir,"--with-mpfr="+base_dir])
        prefix['mpc']=base_dir
        mark_as_done('mpc')
    # gcc
    download('https://ftpmirror.gnu.org/gnu/gcc/gcc-'+opts.gcc_ver,
             "gcc-%s.tar.gz" % opts.gcc_ver)

    os.chdir("gcc-%s" % opts.gcc_ver)

    obj_path=os.path.join(src_dir,"gcc-build")
    if not os.access(obj_path, os.R_OK):
        os.mkdir(obj_path)
        os.chdir(obj_path)
    else:
        os.chdir(obj_path)
        # don't use check_call here, the command may not always complete OK
        subprocess.call(["make","distclean"])
    try:
        gcc_version = list(map(int,opts.gcc_ver.split(".")[:2]))
    except:
        sys.stderr.write('Unknown gcc version format. Expecting "N.N.N".\n')
        exit(1)
    flags=["../gcc-%s/configure" % opts.gcc_ver,
           "--prefix="+base_dir,
           "--program-suffix="+GCC_SUFFIX,
           "--disable-multilib"]
    if gcc_version[0] <= 3:
        unsupported_gcc()
    elif gcc_version[0] >= 4:
        if gcc_version[0] == 4 and gcc_version[1] < 8:
            unsupported_gcc()
        else:
            flags.append("--enable-languages=c,c++,fortran")
            flags.append("--with-gmp="+base_dir)
            flags.append("--with-mpfr="+base_dir)
            flags.append("--with-mpc="+base_dir)

    check_call(flags)
    check_call(["make","-s","-j%s" % opts.ncore])
    check_call(["make","-s","install"])
    deletelibtool()
    os.chdir(src_dir)

def lockfile_path(name,version):
    if version:
        version = '_' + version.replace('.','_')
    path = os.path.join(src_dir,
                        'herwig_bootstrap_%s%s_done' % (name,version))
    return path

def mark_as_done(name,version=''):
    lfpath = lockfile_path(name,version)
    with open(lfpath, 'w') as f:
        f.write('%s\n' % prefix[name])

def build_needed(name,version=''):
    alternate_path = getattr(opts,'%s_loc' % name,False)
    if alternate_path:
        print('Alternative given for ' + name + '.\nUsing ' + alternate_path)
        prefix[name] = alternate_path
        return False
    cmdline_flag_set = getattr(opts,name,False) # default to false if not found

    if cmdline_flag_set:
        return marker_is_missing(name,version)
    else:
        return False

def marker_is_missing(name,version=''):
    lfpath = lockfile_path(name,version)
    try:
        with open(lfpath) as f:
            prefixpath = f.readline().rstrip()
    except EnvironmentError:
        return True
    else:
        print('Marker file for ' + name + version + ' exists in src/, skipping build,')
        print('    using prefix=' + prefixpath)
        prefix[name] = prefixpath
        return False


# download and compile gcc
if build_needed('gcc'):
    buildgcc()
    mark_as_done('gcc')

if opts.gcc:
    default_cc  = os.path.join(bin_dir,'gcc%s' % GCC_SUFFIX)
    default_cxx = os.path.join(bin_dir,'g++%s %s' % (GCC_SUFFIX, opts.cxx11) )
    default_fc  = os.path.join(bin_dir,'gfortran%s' % GCC_SUFFIX)

os.environ['CC']  = default_cc
os.environ['CXX'] = default_cxx
os.environ['FC']  = default_fc
os.environ['F77'] = default_fc

if build_needed('gengetopt'):
    os.chdir(src_dir)
    tmp_ncore=opts.ncore
    opts.ncore=1
    downloadAndCompile("https://ftpmirror.gnu.org/gnu/gengetopt/",
                       "gengetopt-2.22.6",".tar.gz",[])
    opts.ncore=tmp_ncore
    mark_as_done('gengetopt')


# install boost if required
if build_needed('boost'):
    os.chdir(src_dir)
    boost_ver2=opts.boost_ver.replace(".","_")
    boost_base = "boost_"+ boost_ver2
    try :
        download("http://sourceforge.net/projects/boost/files/boost/"+opts.boost_ver,
                 boost_base+".tar.bz2")
    except:
        download("https://dl.bintray.com/boostorg/release/"+opts.boost_ver+"/source",
                 boost_base+".tar.bz2")
    os.chdir(os.path.join(src_dir,boost_base))

    # make sure we use our own compiler
    # this works as long as default_cxx is sufficiently gcc-like
    # need to separate out the cxxflag addition
    boost_cxx = ' '.join(default_cxx.split(' ')[:-1])
    boost_cxxflags = opts.cxx11

    with open('tools/build/src/user-config.jam','w') as f:
        f.write('using gcc : : "%s" : <cxxflags>"%s" ;\n'
                  % (boost_cxx, boost_cxxflags))

    if opts.boost_minimal:
        check_call(["./bootstrap.sh","--prefix="+base_dir,'threading=multi',"--with-libraries=filesystem,system,test"])
    else :
        check_call(["./bootstrap.sh","--prefix="+base_dir,'threading=multi'])
    check_call(["./b2","--layout=tagged","install","-j%s" % opts.ncore])
    os.chdir(src_dir)

    # on OS X, write helper script
    if platform.system() == 'Darwin':
        helpername='./boost-osx-path-fix'
        with open(helpername,'w') as f:
            f.write(
"""\
#!/bin/bash
for i in %s/lib*/libboost*.dylib
do
  install_name_tool -id $i $i || true
  if [ $(basename $i) == 'libboost_filesystem-mt.dylib' ]; then
      install_name_tool -change libboost_system-mt.dylib $(dirname $i)/libboost_system-mt.dylib $i || true
  fi
done
""" % base_dir)
        os.chmod(helpername,0o755)
        check_call([helpername])

    prefix['boost']=base_dir
    mark_as_done('boost')


# install gsl if required
if build_needed('gsl'):
    os.chdir(src_dir)
    downloadAndCompile("https://ftpmirror.gnu.org/gnu/gsl",
                       "gsl-"+opts.gsl_ver,".tar.gz",
                       [])
    prefix['gsl']=base_dir
    mark_as_done('gsl')


# install fastjet if required
if build_needed('fastjet'):
    os.chdir(src_dir)
    downloadAndCompile("http://fastjet.fr/repo",
                       "fastjet-"+opts.fastjet_ver,".tar.gz",
                       ["--enable-allcxxplugins","--disable-auto-ptr"])
    prefix['fastjet']=base_dir
    mark_as_done('fastjet')

if build_needed('fastjet_contrib'):
    download("https://fastjet.hepforge.org/contrib/downloads",
             "fjcontrib-"+opts.fastjet_contrib_ver+".tar.gz")
    os.chdir(os.path.join(src_dir,"fjcontrib-"+opts.fastjet_contrib_ver))
    # force use of CXX from configure
    files=glob.glob("*/Makefile")
    files.append("Makefile.in")
    for make in files :
        with open('tmp.tmp','w') as outfile:
            with open(make) as infile:
                for line in infile:
                    if("CXX=" not in line) :
                        outfile.write(line)
        shutil.move('tmp.tmp',make)
    # compile
    compile(["--fastjet-config=%s/bin/fastjet-config" % base_dir])
    # rivet needs these options for the install
    os.chdir(os.path.join(src_dir,"fjcontrib-"+opts.fastjet_contrib_ver))
    check_call(["make","fragile-shared-install","-j%s" % opts.ncore])
    os.chdir(src_dir)

    prefix['fastjet_contrib']=base_dir
    mark_as_done('fastjet_contrib')

# install hepmc if needed
if build_needed('hepmc'):
    downloadAndCompile("http://hepmc.web.cern.ch/hepmc/releases",
                       "hepmc"+opts.hepmc_ver,".tgz",
                       ["--with-momentum=GEV","--with-length=MM"])
    prefix['hepmc']=base_dir
    mark_as_done('hepmc')

# install lhapdf if needed
if build_needed('lhapdf'):
    os.chdir(src_dir)
    args=[]
    if prefix['boost']:
        args.append("--with-boost="+prefix['boost'])
    downloadAndCompile("https://lhapdf.hepforge.org/downloads",
                 "LHAPDF-"+opts.lhapdf_ver, ".tar.gz",
                 args)
    for pdf in opts.pdfs :
        lhapdftool = os.path.join(bin_dir,'lhapdf')
        check_call([lhapdftool,
                    '--listdir='+os.path.join(base_dir,'share','LHAPDF'),
                    '--pdfdir='+os.path.join(base_dir,'share','LHAPDF'),
                    "install",
                    pdf])

    prefix['lhapdf']=base_dir
    mark_as_done('lhapdf')

if opts.lhapdf:
    os.environ['LHAPATH'] = os.path.join(base_dir,'share','LHAPDF')

# install yoda if needed
if build_needed('yoda'):
    os.chdir(src_dir)
    # from tar ball
    if not opts.yoda_hg:
        download("https://yoda.hepforge.org/downloads/",
                 "YODA-"+opts.yoda_ver+".tar.bz2")
        os.chdir(os.path.join(src_dir,"YODA-"+opts.yoda_ver))
    else :
        if opts.yoda_ver :
            if len(opts.yoda_ver)==5:
                branch="yoda-"+opts.yoda_ver
            else :
                branch=opts.yoda_ver
        else :
            branch=""
        checkout(src_dir,"YODA",opts.yoda_ver,opts.yoda_repo,branch)
    if sys.version_info[0] == 3:
        for val in ["pyext/yoda/core.cpp","pyext/yoda/util.cpp"]:
            if os.path.isfile(val) : os.remove(val)

    compile([] if opts.yoda_root else ['--disable-root'])
    prefix['yoda']=base_dir
    mark_as_done('yoda')

# install rivet if needed
if build_needed('rivet'):
    os.chdir(src_dir)
    # from tar ball
    if not opts.rivet_hg:
        download("https://rivet.hepforge.org/downloads/",
                 "Rivet-"+opts.rivet_ver+".tar.bz2")
        os.chdir(os.path.join(src_dir,"Rivet-"+opts.rivet_ver))
    else:
        if len(opts.rivet_ver)==5:
            branch="rivet-"+opts.rivet_ver
        else:
            branch=opts.rivet_ver
        checkout(src_dir,"Rivet",opts.rivet_ver,opts.rivet_repo,branch)
    with open('include/Rivet/Tools/RivetSTL.hh') as f:
        if '<functional>' not in f.read():
            patch("Rivet-"+opts.rivet_ver, """\
diff -r de94069c6b1a include/Rivet/Tools/RivetSTL.hh
--- a/include/Rivet/Tools/RivetSTL.hh   Fri Apr 28 22:42:50 2017 +0200
+++ b/include/Rivet/Tools/RivetSTL.hh   Thu May 11 10:28:36 2017 +0100
@@ -4,2 +4,3 @@
 #include <string>
+#include <array>
 #include <vector>
@@ -21,2 +22,3 @@
 #include <limits>
+#include <functional>

""")
    args = []
    for tool in ['gsl','yoda','hepmc','fastjet']:
        if prefix[tool]:
            args.append( "--with-%s=%s" % (tool,prefix[tool]) )
    compile(args)
    prefix['rivet']=base_dir
    mark_as_done('rivet')


# install thepeg if needed
if build_needed('thepeg',opts.thepeg_ver):
    os.chdir(src_dir)
    # from tar ball

    if not opts.thepeg_hg:
        download("https://thepeg.hepforge.org/downloads","ThePEG-"+opts.thepeg_ver+".tar.bz2")
        os.chdir(os.path.join(src_dir,"ThePEG-"+opts.thepeg_ver))
    else:
        if len(opts.thepeg_ver)==5:
            branch="release-"+opts.thepeg_ver[:3].replace(".","-")
        else:
            branch=opts.thepeg_ver
        checkout(src_dir,"ThePEG",opts.thepeg_ver,opts.thepeg_repo,branch)

    args=[]
    for tool in ['boost','gsl','rivet','hepmc','fastjet','lhapdf']:
        if prefix[tool]:
            args.append( "--with-%s=%s" % (tool,prefix[tool]) )
    compile(args)
    prefix['thepeg']=base_dir
    mark_as_done('thepeg',opts.thepeg_ver)

# function to run madgraph
def runMadgraph(mgCommand) :
    with open('proc.dat', 'w') as f:
        f.write(mgCommand)

    mg_exe = os.path.join(prefix['madgraph'],'bin','mg5_aMC')
    check_call([mg_exe,'proc.dat'])
# install madgraph
if build_needed('madgraph'):
    os.chdir(src_dir)
    # from tar ball
    if not opts.madgraph_bzr:
        mg_name = "MG5_aMC_v"+opts.madgraph_ver.replace(".","_")
        mg_tar  = "MG5_aMC_v%s" % opts.madgraph_ver
        if sys.version_info[0] == 3 :
            mg_name +="_py3"
            mg_tar+=".py3"
        mg_tar+=".tar.gz"
        try :
            download("http://madgraph.physics.illinois.edu/Downloads/",mg_tar)
        except :
            print("Madgraph download for Illinois server failed, trying launchpad")
            vSplit=opts.madgraph_ver.split(".")
            mg_loc="https://launchpad.net/mg5amcnlo/%s.0/%s.%s.x/+download" % (vSplit[0],vSplit[0],
                                                                               vSplit[1])
            download(mg_loc,mg_tar)
        prefix['madgraph']=os.path.join(opt_dir, mg_name)
        print('mv ' + os.path.join(src_dir, mg_name) + os.path.join(opt_dir, mg_name))
        shutil.move(os.path.join(src_dir, mg_name), os.path.join(opt_dir, mg_name))
        del mg_name
    else :
        checkout(opt_dir,"madgraph",opts.madgraph_ver,opts.madgraph_repo,"",'bzr')
        prefix['madgraph']=os.path.join(opt_dir,"madgraph")

    # temp directory for madgraph
    mg_tmp_dir = os.path.join(prefix['madgraph'],'tmp_hw_bootstrap_test')

    if not os.path.isdir(mg_tmp_dir):
        os.mkdir(mg_tmp_dir)

    os.chdir(mg_tmp_dir)

    # run madgraph so loop stuff is installed
    mg_initial_run = """\
set auto_update 0
set cpp_compiler {cxx}
set fortran_compiler {fc}
import model sm
generate g g > h > w+ w- [QCD]
output madevent MG5
0
""".format(cxx=default_cxx,fc=default_fc)

    runMadgraph(mg_initial_run)

    # force import of the heft model
    heftTemplate = """\
set auto_update 0
set cpp_compiler {cxx}
set fortran_compiler {fc}
{convert}
import model heft

"""
    mg_heft = heftTemplate.format(cxx=default_cxx,fc=default_fc,convert="")
    runMadgraph(mg_heft)
    # python 3 try to convert the model
    if sys.version_info[0] == 3 :
        print ("Python 3 trying to convert heft model")
        mg_heft = heftTemplate.format(cxx=default_cxx,fc=default_fc,
                                      convert="convert model %s/models/heft\ny" % prefix['madgraph'])
        runMadgraph(mg_heft)
    # remove tmp directory
    shutil.rmtree(mg_tmp_dir)

    mark_as_done('madgraph')

# install the NLO codes if needed
# install njet if required
if build_needed('njet'):
    os.chdir(src_dir)
    download("https://bitbucket.org/njet/njet/downloads",
             "njet-"+opts.njet_ver+".tar.gz")
    patch("njet-"+opts.njet_ver,
b"""\
diff blha/njet_olp.cpp
--- a/blha/njet_olp.cpp   2014-04-25 12:38:30.000000000 +0100
+++ b/blha/njet_olp.cpp   2016-11-22 12:44:34.187725299 +0000
@@ -1076,12 +1076,12 @@
   string line;
   int linenum = 0;

-  while (is_good && (is_good = getline(*input, line))) {
+  while (is_good && (is_good = bool(getline(*input, line)))) {
     linenum++;
     if (line.find(SIGNPREF) == 0) {
       is_njet = true;
       if (stringstream(line.substr(SIGNPREF.length())) >> signval) {
-        is_good = getline(*input, line);
+        is_good = bool(getline(*input, line));
         linenum++;
         body.push_back(line);
         continue;
""")
    compile(["--disable-autoflags",
             "FC="+default_fc,
             "F77="+default_fc,
             "FFLAGS=-std=legacy"])
    prefix['njet']=base_dir
    mark_as_done('njet')


OPENLOOPS_CONFIG = """\
[OpenLoops]
fortran_compiler = {fc}
compile_extra = 0
"""

# install openloops if needed
if build_needed('openloops'):
    if not opts.openloops_svn:
        os.chdir(opt_dir)
        download("https://openloops.hepforge.org/downloads","OpenLoops-"+opts.openloops_ver+".tar.gz")
        os.chdir(os.path.join(opt_dir,"OpenLoops-"+opts.openloops_ver))

        with open('openloops.cfg','w') as f:
            f.write(OPENLOOPS_CONFIG.format(fc=default_fc))

        # We know our gcc works. Disable the strange test that uses the system version number.
        if opts.gcc:
            searchtext = "env.subst('$CCVERSION').split('.')[:2])) < (4,6)"
            with open('tmp.tmp','w') as outfile:
                with open('SConstruct') as infile:
                    for line in infile:
                        outfile.write(line.replace(searchtext, searchtext + " and False"))
            shutil.move('tmp.tmp','SConstruct')
            del searchtext
        check_call(["./scons","--jobs=%s" % opts.ncore])
        check_call(["./openloops","libinstall",opts.openloops_processes,
                    "num_jobs=%s" % opts.ncore])
        os.chdir(src_dir)
        prefix['openloops']=opt_dir+"/OpenLoops-"+opts.openloops_ver
        mark_as_done('openloops')
    else:
        checkout(opt_dir,"OpenLoops",opts.openloops_ver,opts.openloops_repo,opts.openloops_ver,'svn',
                 revision='1945')

        with open('openloops.cfg','w') as f:
            f.write(OPENLOOPS_CONFIG.format(fc=default_fc))

        # We know our gcc works. Disable the strange test that uses the system version number.
        if opts.gcc:
            searchtext = "env.subst('$CCVERSION').split('.')[:2])) < (4,6)"
            with open('tmp.tmp','w') as outfile:
                with open('SConstruct') as infile:
                    for line in infile:
                        outfile.write(line.replace(searchtext, searchtext + " and False"))
            shutil.move('tmp.tmp','SConstruct')
            del searchtext

        check_call(["./openloops","libinstall",opts.openloops_processes,
                    "num_jobs=%s" % opts.ncore])
        os.chdir(src_dir)
        prefix['openloops']=opt_dir+"/OpenLoops"
        mark_as_done('openloops')


# install gosam if needed
if build_needed('gosam'):
    os.chdir(src_dir)
    # build qgraf
    if marker_is_missing('qgraf'):
        download('https://herwig.hepforge.org/downloads/mirror',"qgraf-3.1.4.tgz")
        os.chdir(os.path.join(src_dir,'qgraf-3.1.4'))
        check_call([default_fc,'qgraf-3.1.4.f','-o','qgraf','-O2'])
        shutil.move('qgraf',os.path.join(bin_dir,'qgraf'))
        prefix['qgraf']=base_dir
        os.chdir(src_dir)
        mark_as_done('qgraf')
    # build form
    if marker_is_missing('form'):
        # https://github.com/vermaseren/form/releases/tag/v4.1-20131025
        checkout(src_dir, 'FORM', '4.1', 'https://github.com/vermaseren/form.git','v4.1-20131025','git')
        compile([])
        prefix['form']=base_dir
        mark_as_done('form')
    # build gosam-contrib
    if marker_is_missing('gosam-contrib'):
        #download('https://www.hepforge.org/archive/gosam/gosam-contrib-2.0-20150803.tar.gz',
        #         "gosam-contrib-2.0.tar.gz", distinct=True)
        download('https://gosam.hepforge.org/downloads/gosam-contrib-2.0-20170614.tar.gz',
                 "gosam-contrib-2.0.tar.gz", distinct=True)
        os.chdir(os.path.join(src_dir,'gosam-contrib-2.0'))
        # Gosams build system sometimes hangs and needs a second trial
        try:
          compile(["FFLAGS=-std=legacy"])
        except subprocess.CalledProcessError:
          compile(["FFLAGS=-std=legacy"])
        prefix['gosam-contrib']=base_dir
        mark_as_done('gosam-contrib')

    download('https://gosam.hepforge.org/downloads/','gosam-2.0.4-6d9f1cba.tar.gz')
    try:
        os.chdir(os.path.join(src_dir,'gosam-2.0.4'))
    except OSError:
        os.chdir(os.path.join(src_dir,'gosam'))

    check_call(["./setup.py",
                "install",
                "--prefix="+base_dir,
                "-f"])
    os.chdir(src_dir)
    prefix['gosam']=base_dir
    mark_as_done('gosam')


# install vbfnlo if required
if build_needed('vbfnlo'):
    os.chdir(src_dir)
    # from tar ball
    if not opts.vbfnlo_git:
        download("https://www.itp.kit.edu/vbfnlo/archive","vbfnlo-"+opts.vbfnlo_ver+".tgz")
        os.chdir(os.path.join(src_dir,"VBFNLO-"+opts.vbfnlo_ver))
    else:
        checkout(src_dir,"VBFNLO",opts.vbfnlo_ver,opts.vbfnlo_repo,"v"+opts.vbfnlo_ver,'git')
    if opts.vbfnlo_ver == "3.0.0beta1" or opts.vbfnlo_ver == "3.0.0beta2":
        # 3.0.0beta1 and 2 did not yet accept setting F77
        del os.environ['F77']
    check_call(["./configure","--prefix="+base_dir,"--enable-processes="+opts.vbfnlo_processes,
                "FCFLAGS=-std=legacy"])
    check_call(["make","-s","-j%s"%opts.ncore])
    check_call(["make","-s","install"])
    if opts.vbfnlo_ver == "3.0.0beta1" or opts.vbfnlo_ver == "3.0.0beta2":
        # reinsert F77 for the others
        os.environ['F77'] = default_fc
    os.chdir(src_dir)
    prefix['vbfnlo']=base_dir
    mark_as_done('vbfnlo')

# # install TAUOLA if needed
# if build_needed('tauola'):
#     download("http://tauolapp.web.cern.ch/tauolapp/resources/TAUOLA." + opts.tauola_ver,
#              "TAUOLA." + opts.tauola_ver + ".tar.gz")
#     os.chdir(os.path.join(src_dir,"TAUOLA"))
#     args=["./configure","--prefix="+base_dir]
#     if prefix['hepmc']:
#         args.append("--with-hepmc="+prefix['hepmc'])
#     check_call(args)
#     check_call(["make"])
#     check_call(["make","install"])
#     os.chdir(src_dir)
#     prefix['tauola']=base_dir
#     mark_as_done('tauola')

# # install PHOTOS if needed
# if build_needed('photos'):
#     download("http://photospp.web.cern.ch/photospp/resources/PHOTOS."+opts.photos_ver,
#              "PHOTOS."+opts.photos_ver+".tar.gz")
#     os.chdir(os.path.join(src_dir,"PHOTOS"))
#     args=["./configure","--prefix="+base_dir]
#     if prefix['hepmc']:
#         args.append("--with-hepmc="+prefix['hepmc'])
#     check_call(args)
#     check_call(["make","-j%s" % opts.ncore])
#     check_call(["make","install"])
#     os.chdir(src_dir)
#     prefix['photos']=base_dir
#     mark_as_done('photos')

# install Pytiha8 if needed
if build_needed('pythia'):
    os.chdir(src_dir)
    pythia_version = "8.240".replace(".","")
    download("http://home.thep.lu.se/~torbjorn/pythia8","pythia%s.tgz" % pythia_version)
    patch("pythia%s" % pythia_version,
b"""\
--- a/src/ResonanceWidthsDM.cc	2019-01-17 14:32:39.060600106 +0100
+++ b/src/ResonanceWidthsDM.cc.orig	2019-01-17 13:36:16.289071230 +0100
@@ -387,11 +387,12 @@
 // Calculate various common prefactors for the current mass.

 void ResonanceChaD::calcPreFac(bool) {
-
   // Common coupling factors.
   double dm = particleDataPtr->m0(59) - particleDataPtr->m0(57);
-  preFac =  4.0 * 6.993e-13 * sqrt(1. - pow2(0.1396/dm)) * pow3(dm);
-  if (dm < 0.1396) preFac = 0.0;
+  if(dm>=0.1396)
+    preFac =  4.0 * 6.993e-13 * sqrt(1. - pow2(0.1396/dm)) * pow3(dm);
+  else
+    preFac = 0.0;

 }

""")
    os.chdir(os.path.join(src_dir,"pythia%s" % pythia_version))
    args=["./configure",
          "--prefix=%s" % base_dir,
          "--enable-shared",]
### newer versions need this instead of USRCXXFLAGS
###           "--cxx-common='-O2 -pedantic -W -Wall -Wshadow'"]
    if prefix['hepmc']:
        args.append("--with-hepmc2=%s" % prefix['hepmc'])
    os.environ['USRCXXFLAGS'] = opts.cxx11
    check_call(args)
    check_call(["make","-j%s" % opts.ncore])
    check_call(["make","-s","install"])
    del os.environ['USRCXXFLAGS']
    os.chdir(src_dir)
    prefix['pythia'] = base_dir
    mark_as_done('pythia')

# install EvtGen if needed
if build_needed('evtgen'):
    os.chdir(src_dir)
    evtgen_version = '01.07.00'
    evtgen_srcpath = os.path.join('EvtGen', 'R'+evtgen_version.replace('.','-'))
    download("https://evtgen.hepforge.org/downloads",
             "EvtGen-%s.tar.gz" % evtgen_version)
    os.chdir(os.path.join(src_dir,evtgen_srcpath))
    # don't use check_call here, the command may not always complete OK
    subprocess.call(["make","distclean"])
    patch(evtgen_srcpath,
("""\
diff -r a4c4f60ba4f7 src/EvtGenModels/EvtCBTo3piP00.cpp
--- a/src/EvtGenModels/EvtCBTo3piP00.cpp	2017-12-13 17:02:55.000000000 +0100
+++ b/src/EvtGenModels/EvtCBTo3piP00.cpp	2019-04-18 15:03:33.428088846 +0200
@@ -56,6 +56,16 @@
   checkSpinDaughter(1,EvtSpinType::SCALAR);
   checkSpinDaughter(2,EvtSpinType::SCALAR);

+
+  int iset=10000;
+  double alpha = getArg(0);
+  EvtVector4R pin,p4pi1,p4Gamma11,p4Gamma12;
+  EvtVector4R p4Gamma21,p4Gamma22;
+  double realA,imgA,realbarA,imgbarA;
+  generator.Evt3piP00(alpha, iset, pin, p4Gamma11, p4Gamma12,
+                      p4Gamma21, p4Gamma22, realA, imgA, realbarA,
+                      imgbarA);
+
 }


@@ -83,16 +93,7 @@

   EvtVector4R p4[3];
   double alpha = getArg(0);
-  int iset;
-  static int first=1;
-
-  if (first==1) {
-    iset=10000;
-    first=0;
-  }
-  else{
-    iset=0;
-  }
+  int iset=0;

   EvtVector4R p4pi1,p4Gamma11,p4Gamma12;
   EvtVector4R p4Gamma21,p4Gamma22;
diff -r a4c4f60ba4f7 src/EvtGenModels/EvtCBTo3piMPP.cpp
--- a/src/EvtGenModels/EvtCBTo3piMPP.cpp	2017-12-13 17:02:55.000000000 +0100
+++ b/src/EvtGenModels/EvtCBTo3piMPP.cpp	2019-04-18 15:04:00.380097072 +0200
@@ -57,6 +57,16 @@
   checkSpinDaughter(1,EvtSpinType::SCALAR);
   checkSpinDaughter(2,EvtSpinType::SCALAR);

+
+  EvtVector4R p4[3];
+  double alpha = getArg(0);
+
+  int iset=10000;
+
+  double realA,imgA,realbarA,imgbarA;
+
+  generator.Evt3piMPP(alpha, iset, p4[0], p4[1], p4[2],
+                  realA, imgA, realbarA, imgbarA);
 }

 void EvtCBTo3piMPP::initProbMax(){
@@ -81,17 +91,7 @@
   EvtVector4R p4[3];
   double alpha = getArg(0);

-  int iset;
-
-  static int first=1;
-
-  if (first==1) {
-    iset=10000;
-    first=0;
-  }
-  else{
-    iset=0;
-  }
+  int iset=0;

   double realA,imgA,realbarA,imgbarA;

diff -r a4c4f60ba4f7 configure
--- a/configure Thu May 11 12:16:17 2017 +0100
+++ b/configure Thu May 11 12:47:43 2017 +0100
@@ -158,3 +158,3 @@
 #
-CXX=g++
+CXX="%s"
 CXXFLAGS_OPT="-O2 -Wall"
@@ -163,3 +163,3 @@
 CFLAGS_DBG=-g
-FC=gfortran
+FC="%s"
 FFLAGS_OPT="-O2 -Wuninitialized"
@@ -179,116 +179,18 @@
 #
 # Find platform.
 #
-ARCH=`uname`
-theGcc=`g++ --version | grep '[0-9]\.[0-9]\.[0-9]' -o | head -1 | awk -F . '{print $1}'`
-if [ ${theGcc} = 4 ]; then
-  ARCH=${ARCH}-gcc4
-fi
-if [ ${theGcc} = 5 ]; then
-  ARCH=${ARCH}-gcc5
-fi
-if [ ${theGcc} = 6 ]; then
-  ARCH=${ARCH}-gcc6
-fi
+ARCH=`uname`-gcc4
 echo "Platform is $ARCH"

 #default platform settings:
 FFLAGS="${FFLAGS_OPT}"
 CFLAGS="${CFLAGS_OPT}"
 CXXFLAGS="${CXXFLAGS_OPT}"
-FLIBS="-lfrtbegin -lg2c"
+FLIBS="-lgfortran"
 SOFLAGS="-soname"

-if [ ${COMPMODE} = OPT ]; then
-  FFLAGS="${FFLAGS_OPT}"
-  CFLAGS="${CFLAGS_OPT}"
-  CXXFLAGS="${CXXFLAGS_OPT}"
-fi
-if [ ${COMPMODE} = DBG ]; then
-  FFLAGS="${FFLAGS_DBG}"
-  CFLAGS="${CFLAGS_DBG}"
-  CXXFLAGS="${CXXFLAGS_DBG}"
-fi
-if [ $ARCH = Linux ]; then
-  FFLAGS="${FFLAGS_OPT} -Wno-globals"
-  CFLAGS="${CFLAGS_OPT}"
-  CXXFLAGS="${CXXFLAGS_OPT}"
-  FLIBS="-lfrtbegin -lg2c"
-  if [ ${COMPMODE} = OPT ]; then
-    FFLAGS="${FFLAGS_OPT}"
-    CFLAGS="${CFLAGS_OPT}"
-    CXXFLAGS="${CXXFLAGS_OPT}"
-  fi
-  if [ ${COMPMODE} = DBG ]; then
-    FFLAGS="${FFLAGS_DBG} -Wno-globals"
-    CFLAGS="${CFLAGS_DBG}"
-    CXXFLAGS="${CXXFLAGS_DBG}"
-  fi
-fi
-
-# Linux platform with gcc4: new Fortran90 compiler.
-if [ $ARCH = Linux-gcc4 ]; then
-  FFLAGS="${FFLAGS_OPT}"
-  CFLAGS="${CFLAGS_OPT}"
-  CXXFLAGS="${CXXFLAGS_OPT}"
-  FLIBS="-lgfortran"
-  if [ ${COMPMODE} = OPT ]; then
-    FFLAGS="${FFLAGS_OPT}"
-    CFLAGS="${CFLAGS_OPT}"
-    CXXFLAGS="${CXXFLAGS_OPT}"
-  fi
-  if [ ${COMPMODE} = DBG ]; then
-    FFLAGS="${FFLAGS_DBG}"
-    CFLAGS="${CFLAGS_DBG}"
-    CXXFLAGS="${CXXFLAGS_DBG}"
-  fi
-fi
-if [ $ARCH = Linux-gcc5 ]; then
-  FFLAGS="${FFLAGS_OPT}"
-  CFLAGS="${CFLAGS_OPT}"
-  CXXFLAGS="${CXXFLAGS_OPT}"
-  FLIBS="-lgfortran"
-  if [ ${COMPMODE} = OPT ]; then
-    FFLAGS="${FFLAGS_OPT}"
-    CFLAGS="${CFLAGS_OPT}"
-    CXXFLAGS="${CXXFLAGS_OPT}"
-  fi
-  if [ ${COMPMODE} = DBG ]; then
-    FFLAGS="${FFLAGS_DBG}"
-    CFLAGS="${CFLAGS_DBG}"
-    CXXFLAGS="${CXXFLAGS_DBG}"
-  fi
-fi
-if [ $ARCH = Linux-gcc6 ]; then
-  FFLAGS="${FFLAGS_OPT}"
-  CFLAGS="${CFLAGS_OPT}"
-  CXXFLAGS="${CXXFLAGS_OPT}"
-  FLIBS="-lgfortran"
-  if [ ${COMPMODE} = OPT ]; then
-    FFLAGS="${FFLAGS_OPT}"
-    CFLAGS="${CFLAGS_OPT}"
-    CXXFLAGS="${CXXFLAGS_OPT}"
-  fi
-  if [ ${COMPMODE} = DBG ]; then
-    FFLAGS="${FFLAGS_DBG}"
-    CFLAGS="${CFLAGS_DBG}"
-    CXXFLAGS="${CXXFLAGS_DBG}"
-  fi
-fi
-
-# Add C++11 options if required
-theGcc2=`g++ --version | grep '[0-9]\.[0-9]\.[0-9]' -o | head -1 | awk -F . '{print $2}'`
-gccVar=`echo $theGcc`
-gccVar2=`echo $theGcc2`
 # Flag to make sure c++11 is enabled for compiling certain classes, e.g. MT random engine.
 CPP11=1
-# Check that we have gcc version 4.7 and above
-if [ $gccVar -le 4 ]; then
-  if [ $gccVar2 -le 6 ]; then
-    echo "Not enabling c++11 features"
-    CPP11=0
-  fi
-fi

 if [ $CPP11 = 1 ]; then
   echo "c++11 is enabled"
@@ -296,7 +198,7 @@

 # Mac OS platform with gcc4
 if [[ $ARCH == Darwin* ]]; then
-  tt=`gfortran -print-search-dirs|grep libraries|cut -d'=' -f2|sed  's/:/ /g'`
+  tt=`$FC -print-search-dirs|grep libraries|cut -d'=' -f2|sed  's/:/ /g'`
   LIBGFORTRANLOCATION=''
   for i in $tt
   do

""" % (default_cxx, default_fc)).encode())
    if platform.system() == 'Darwin':
        patch(evtgen_srcpath,
b"""\
$ diff -u configure
--- a/configure   2016-11-22 17:37:50.000000000 +0100
+++ b/configure   2016-11-22 22:46:06.000000000 +0100
@@ -312,10 +312,10 @@
 LIBDIR_ARCHIVE = \$(EVTGENDIR)/lib/archive
 LIBDIRLIST = -lEvtGen

-LIB_SHARED = \$(LIBDIR_SHARED)/lib\$(GENERATOR).so
+LIB_SHARED = \$(LIBDIR_SHARED)/lib\$(GENERATOR).dylib
 LIB_ARCHIVE = \$(LIBDIR_ARCHIVE)/lib\$(GENERATOR).a

-LIBEXT_SHARED = \$(LIBDIR_SHARED)/lib\$(GENERATOR)External.so
+LIBEXT_SHARED = \$(LIBDIR_SHARED)/lib\$(GENERATOR)External.dylib
 LIBEXT_ARCHIVE = \$(LIBDIR_ARCHIVE)/lib\$(GENERATOR)External.a

 # Flags:
"""
)
    args=["./configure","--prefix="+base_dir]
    if prefix['hepmc']:
        args.append("--hepmcdir="+prefix['hepmc'])
    # if prefix['tauola']:
    #     args.append("--tauoladir="+prefix['tauola'])
    # if prefix['photos']:
    #     args.append("--photosdir="+prefix['photos'])
    if prefix['pythia']:
        args.append("--pythiadir="+prefix['pythia'])
    check_call(args)
    # Has to be single thread build. Dependencies are broken otherwise.
    check_call(["make","-j1"])
    check_call(["make","install"])
    if platform.system() == 'Darwin':
        # fix path settings to help autodetection of lib locations
        os.chdir(os.path.join(base_dir,'lib'))
        for i in ["libEvtGen.dylib", "libEvtGenExternal.dylib"]:
            check_call(["install_name_tool","-id",os.path.join(os.getcwd(),i),i])
        for i in ["libEvtGen.dylib","libpythia8.dylib","liblhapdfdummy.dylib"]:
            check_call(["install_name_tool","-change",i,os.path.join(os.getcwd(),i),"libEvtGenExternal.dylib"])

    os.chdir(src_dir)
    prefix['evtgen']=base_dir
    mark_as_done('evtgen')

# install herwig if needed
if build_needed('herwig',opts.herwig_ver):
    os.chdir(src_dir)
    # from tar ball
    if not opts.herwig_hg:
        download("https://herwig.hepforge.org/downloads/","Herwig-"+opts.herwig_ver+".tar.bz2")
        os.chdir(os.path.join(src_dir,"Herwig-"+opts.herwig_ver))
    else:
        if len(opts.herwig_ver)==5:
            branch = "herwig-"+opts.herwig_ver[:3].replace(".","-")
        else:
            branch = opts.herwig_ver
        checkout(src_dir,"Herwig",opts.herwig_ver,opts.herwig_repo,branch)
    args=[]
    for tool in ['thepeg','boost','gsl','fastjet',
                 'madgraph','njet','openloops','gosam','vbfnlo',
                 'pythia','evtgen']:
        if prefix[tool]:
            args.append( "--with-%s=%s" % (tool,prefix[tool]) )
    compile(args)
    prefix['herwig']=base_dir
    mark_as_done('herwig',opts.herwig_ver)

# need to have Herwig if we want HJets++
if not opts.herwig:
    opts.hjets = False

# install hjets if needed
if build_needed('hjets'):
    os.chdir(src_dir)
    # from tar ball
    if not opts.hjets_hg:
        download("http://www.hepforge.org/archive/hjets",
                 "HJets-"+opts.hjets_ver+".tar.bz2")
        os.chdir(os.path.join(src_dir,"HJets-"+opts.hjets_ver))
    else :
        if len(opts.hjets_ver)==3:
            branch = "release "+opts.hjets_ver
        else:
            branch = opts.hjets_ver
        checkout(src_dir,"HJets",opts.hjets_ver,opts.hjets_repo,branch)
    args=[]
    args.append("--with-herwig="+prefix['herwig'])
    del os.environ['F77']
    compile(args)
    os.environ['F77'] = default_fc
    prefix['hjets']=base_dir
    lib_dirs = os.pathsep.join([os.path.join(prefix['hjets'], 'lib64','HJets'),
                                os.path.join(prefix['hjets'], 'lib','HJets'),
                                lib_dirs])
    mark_as_done('hjets')

# generate an 'activate' shell include like python's virtualenv does
from string import Template

class ShellTemplate(Template):
    delimiter = '@'

ACTIVATE = ShellTemplate("""\
# Herwig bootstrap 'activate',
# based on Python's virtualenv mechanism

# This file must be used with "source @{bin_dir}/activate"
# *from bash or zsh*. You cannot run it directly.

deactivate () {

    # reset old environment variables
    if [ "${_OLD_VIRTUAL_PATH-}" = "Unset" ] ; then
        unset PATH
        unset _OLD_VIRTUAL_PATH
    elif [ -n "${_OLD_VIRTUAL_PATH-}" ] ; then
        PATH="$_OLD_VIRTUAL_PATH"
        export PATH
        unset _OLD_VIRTUAL_PATH
    fi

    if [ "${_OLD_VIRTUAL_PYTHONPATH-}" = "Unset" ] ; then
        unset PYTHONPATH
        unset _OLD_VIRTUAL_PYTHONPATH
    elif [ -n "${_OLD_VIRTUAL_PYTHONPATH-}" ] ; then
        PYTHONPATH="$_OLD_VIRTUAL_PYTHONPATH"
        export PYTHONPATH
        unset _OLD_VIRTUAL_PYTHONPATH
    fi

    if [ "${_OLD_VIRTUAL_LHAPATH-}" = "Unset" ] ; then
        unset LHAPATH
        unset _OLD_VIRTUAL_LHAPATH
    elif [ -n "${_OLD_VIRTUAL_LHAPATH-}" ] ; then
        LHAPATH="$_OLD_VIRTUAL_LHAPATH"
        export LHAPATH
        unset _OLD_VIRTUAL_LHAPATH
    fi

    if [ "${_OLD_VIRTUAL_@{ld_env_name}-}" = "Unset" ] ; then
        unset @{ld_env_name}
        unset _OLD_VIRTUAL_@{ld_env_name}
    elif [ -n "${_OLD_VIRTUAL_@{ld_env_name}-}" ] ; then
        @{ld_env_name}="$_OLD_VIRTUAL_@{ld_env_name}"
        export @{ld_env_name}
        unset _OLD_VIRTUAL_@{ld_env_name}
    fi

    if [ "${_OLD_VIRTUAL_CC-}" = "Unset" ] ; then
        unset CC
        unset _OLD_VIRTUAL_CC
    elif [ -n "${_OLD_VIRTUAL_CC-}" ] ; then
        CC="$_OLD_VIRTUAL_CC"
        export CC
        unset _OLD_VIRTUAL_CC
    fi

    if [ "${_OLD_VIRTUAL_CXX-}" = "Unset" ] ; then
        unset CXX
        unset _OLD_VIRTUAL_CXX
    elif [ -n "${_OLD_VIRTUAL_CXX-}" ] ; then
        CXX="$_OLD_VIRTUAL_CXX"
        export CXX
        unset _OLD_VIRTUAL_CXX
    fi

    if [ "${_OLD_VIRTUAL_FC-}" = "Unset" ] ; then
        unset FC
        unset _OLD_VIRTUAL_FC
    elif [ -n "${_OLD_VIRTUAL_FC-}" ] ; then
        FC="$_OLD_VIRTUAL_FC"
        export FC
        unset _OLD_VIRTUAL_FC
    fi

    if [ "${_OLD_VIRTUAL_F77-}" = "Unset" ] ; then
        unset F77
        unset _OLD_VIRTUAL_F77
    elif [ -n "${_OLD_VIRTUAL_F77-}" ] ; then
        F77="$_OLD_VIRTUAL_F77"
        export F77
        unset _OLD_VIRTUAL_F77
    fi

    # This should detect bash and zsh, which have a hash command that must
    # be called to get it to forget past commands.  Without forgetting
    # past commands the $PATH changes we made may not be respected
    if [ -n "${BASH-}" -o -n "${ZSH_VERSION-}" ] ; then
        hash -r 2>/dev/null
    fi

    if [ -n "${_OLD_VIRTUAL_PS1-}" ] ; then
        PS1="$_OLD_VIRTUAL_PS1"
        export PS1
        unset _OLD_VIRTUAL_PS1
    fi

    unset HERWIG_ENV
    if [ ! "${1-}" = "nondestructive" ] ; then
    # Self destruct!
        unset -f deactivate
    fi
}

# unset irrelevant variables
deactivate nondestructive

HERWIG_ENV="@{base_dir}"
export HERWIG_ENV

_OLD_VIRTUAL_PATH="${PATH-Unset}"
PATH="@{bin_dir}:$PATH"
export PATH

_OLD_VIRTUAL_PYTHONPATH="${PYTHONPATH-Unset}"
PYTHONPATH="@{python_path}:$PYTHONPATH"
export PYTHONPATH

_OLD_VIRTUAL_LHAPATH="${LHAPATH-Unset}"
LHAPATH="@{lha_path}:$LHAPATH"
export LHAPATH

_OLD_VIRTUAL_@{ld_env_name}="${@{ld_env_name}-Unset}"
@{ld_env_name}="@{lib_dirs}:$@{ld_env_name}"
export @{ld_env_name}

_OLD_VIRTUAL_CC="${CC-Unset}"
CC="@{default_cc}"
export CC

_OLD_VIRTUAL_CXX="${CXX-Unset}"
CXX="@{default_cxx}"
export CXX

_OLD_VIRTUAL_FC="${FC-Unset}"
FC="@{default_fc}"
export FC

_OLD_VIRTUAL_F77="${F77-Unset}"
F77="@{default_fc}"
export F77

if [ -z "${HERWIG_ENV_DISABLE_PROMPT-}" ] ; then
    _OLD_VIRTUAL_PS1="$PS1"
    if [ "x" != x ] ; then
        PS1="$PS1"
    else
        PS1="(`basename \"$HERWIG_ENV\"`)$PS1"
    fi
    export PS1
fi

# This should detect bash and zsh, which have a hash command that must
# be called to get it to forget past commands.  Without forgetting
# past commands the $PATH changes we made may not be respected
if [ -n "${BASH-}" -o -n "${ZSH_VERSION-}" ] ; then
    hash -r 2>/dev/null
fi

""")

subs = {
    'ld_env_name' : ld_env_name,
    'bin_dir' : bin_dir,
    'base_dir' : base_dir,
    'python_path' : python_path,
    'lib_dirs' : lib_dirs,
    'default_cc' : os.path.basename(default_cc),
    'default_cxx' : os.path.basename(default_cxx),
    'default_fc' : os.path.basename(default_fc),
    'lha_path' : os.path.join(base_dir,'share','LHAPDF')
}

activate_file = os.path.join(bin_dir,'activate')

with open(activate_file,'w') as f:
    f.write(ACTIVATE.substitute(subs))


# back to the original directory
os.chdir(current_dir)

try:
    path_to_activate = os.path.join(os.path.relpath(bin_dir,current_dir),'activate')
except:
    path_to_activate = activate_file

print ("""
################ /  / ^^/ ##########################
############### /--/   / ###########################
############## /  /   / ############################

 Herwig 7 bootstrap was successful.

 $ source %s

     activates all required environment variables.

 $ deactivate

     returns to the original environment variables.
""" % path_to_activate)
